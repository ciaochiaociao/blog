---
title: Bash
---

ref: https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Expansions

## Bash command

```
bash -c "help set"
bash
# common
	  -s Run commands from stdin
	  -c "command"
      -e  Exit immediately if a command exits with a non-zero status.
      -x  Print commands and their arguments as they are executed.
      -v  Print shell input lines as they are read.
      -h  Remember the location of commands as they are looked up.
      -m  Job control is enabled.
      -B  the shell will perform brace expansion
      -H  Enable ! style history substitution.  This flag is on
          by default when the shell is interactive.

# others
      -o option-name
          Set the variable corresponding to option-name:
              allexport    same as -a
              braceexpand  same as -B
              emacs        use an emacs-style line editing interface
              errexit      same as -e
              errtrace     same as -E
              functrace    same as -T
              hashall      same as -h
              histexpand   same as -H
              history      enable command history
              ignoreeof    the shell will not exit upon reading EOF
              interactive-comments
                           allow comments to appear in interactive commands
              keyword      same as -k
              monitor      same as -m
              noclobber    same as -C
              noexec       same as -n
              noglob       same as -f
              nolog        currently accepted but ignored
              notify       same as -b
              nounset      same as -u
              onecmd       same as -t
              physical     same as -P
              pipefail     the return value of a pipeline is the status of
                           the last command to exit with a non-zero status,
                           or zero if no command exited with a non-zero status
              posix        change the behavior of bash where the default
                           operation differs from the Posix standard to
                           match the standard
              privileged   same as -p
              verbose      same as -v
              vi           use a vi-style line editing interface
              xtrace       same as -x
      -a  Mark variables which are modified or created for export.
      -b  Notify of job termination immediately.
      -f  Disable file name generation (globbing).
      -k  All assignment arguments are placed in the environment for a
          command, not just those that precede the command name.
      -n  Read commands but do not execute them.
      -p  Turned on whenever the real and effective user ids do not match.
          Disables processing of the $ENV file and importing of shell
          functions.  Turning this option off causes the effective uid and
          gid to be set to the real uid and gid.
      -t  Exit after reading and executing one command.
      -u  Treat unset variables as an error when substituting.
      -C  If set, disallow existing regular files to be overwritten
          by redirection of output.
      -E  If set, the ERR trap is inherited by shell functions.
      -P  If set, do not resolve symbolic links when executing commands
          such as cd which change the current directory.
      -T  If set, the DEBUG trap is inherited by shell functions.
      --  Assign any remaining arguments to the positional parameters.
          If there are no remaining arguments, the positional parameters
          are unset.
      -   Assign any remaining arguments to the positional parameters.
          The -x and -v options are turned off.
          
$ shopt -s extglob  # does not work in zsh. use `setopt kshglob` instead (not working when testing by myself)
If the extglob shell option is enabled using the shopt builtin, several extended pattern matching operators are recognized.A pattern-list is a list of one or more patterns separated by a |. Composite patterns may be formed using one or more of the following sub-patterns:

?(pattern-list)
Matches zero or one occurrence of the given patterns
*(pattern-list)
Matches zero or more occurrences of the given patterns
+(pattern-list)
Matches one or more occurrences of the given patterns
@(pattern-list)
Matches one of the given patterns
!(pattern-list)
Matches anything except one of the given patterns

$ ls -d !(*@(.c|.h))
$ ls *.!(sh)
```

- Using `+` rather than `-` causes these flags to be turned off.
- The flags can also be used upon invocation of the shell.
- The current set of flags may be found in `$-`.
- The remaining n ARGs are positional parameters and are assigned, in order, to `$1, $2, .. $n`.
- If no ARGs are given, all shell variables are printed.

see also: [Why doesn't set -e (or set -o errexit, or trap ERR) do what I expected?](http://mywiki.wooledge.org/BashFAQ/105)



## Basic

```
$!  # last pid
$?  # last exit code
$$  # $PPID 
```



## Data Types

### Array

```
declare -a some_list
somelist[$index]=value
echo ${somelist[*]}  # values
echo ${somelist[@]}
echo ${!somelist[*]}  # keys
echo ${!somelist[@]}  # keys

echo ${#somelist[*]}  # length of an array
echo ${#somelist[@]}  # length of an array

```

## Lists of Commands

- A `list` is a sequence of one or more pipelines separated by one of the operators

  - ‘;’, ‘&’, 

    - If a command is terminated by the control operator ‘&’, the shell executes the command asynchronously in a subshell. This is known as executing the command in the background, and these are referred to as asynchronous commands. The shell does not wait for the command to finish, and the return status is 0 (true). When job control is not active (see [Job Control](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Job-Control)), the standard input for asynchronous commands, in the absence of any explicit redirections, is redirected from `/dev/null`.
    - Commands separated by a ‘;’ are executed sequentially; the shell waits for each command to terminate in turn. The return status is the exit status of the last command executed.

  - ‘&&’, or ‘||’, 

    - AND and OR lists are sequences of one or more pipelines separated by the control operators ‘&&’ and ‘||’, respectively. 
    - AND and OR lists are executed with left associativity.
    - The return status of AND and OR lists is the exit status of the last command executed in the list.

    An AND list has the form

    ```
    command1 && command2
    ```

    command2 is executed if, and only if, command1 returns an exit status of zero (success).

    An OR list has the form

    ```
    command1 || command2
    ```

    command2 is executed if, and only if, command1 returns a non-zero exit status.

  - and optionally terminated by one of ‘;’, ‘&’, 

  - or a `newline`.

    - A sequence of one or more `newlines` may appear in a `list` to delimit commands, equivalent to a semicolon.

- Of these list operators, ‘&&’ and ‘||’ have equal precedence, followed by ‘;’ and ‘&’, which have equal precedence.

```bash
$ true || echo aaa; echo $?
0
$ true && echo aaa; echo $?
aaa
0

$ false && echo aaa; echo $?
1
$ false || echo aaa; echo $?
aaa
0
```



## Compound Commands (List of Commands)

- [Looping Constructs](##Flow Control)
- [Conditional Constructs](##Flow Control)
- [Grouping Commands](##Grouping Commands)

## Grouping Commands

```bash
$ (echo 'a'; echo 'b'; echo 'c') > group.txt  # in a subshell; () are operators; a\nb\nc
$ { echo 'a'; echo 'b'; echo 'c';} > group.txt  # in the current shell; {} are reserved words, need to be followed by a space. And a semicolon ";" at the end is required (zsh does not have these limitations though.)
```

### Multiple IOs

```bash
# Redirect output to multiple commands
# ref: https://unix.stackexchange.com/questions/28503/how-can-i-send-stdout-to-multiple-commands

# zsh: MULTIOS feature (on by default, and can be turned off by `unsetopt MULTIOS`)
<command> > >(cmd1) > >(cmd2) > >(cmd3)

# bash: (`>()` not available in sh)
<command> | tee >(cmd1) >(cmd2) >(cmd3)

<command> | tee >(cmd1) >(cmd2) >(cmd3) | <cmd_following_command>
# e.g.
cat file.txt | tee >(pbcopy) >(do_stuff) >(do_more_stuff) | grep errors
# This will send all the output of cat file.txt to pbcopy, and you'll only get the result of grep on your console.

# Redirect multiple outputs from multiple commands to another
# ref: https://unix.stackexchange.com/questions/28503/how-can-i-send-stdout-to-multiple-commands

# bash
{ <cmd1>; <cmd2>;} | ...  # or > ...
(<cmd1>; <cmd2>) | ...  # or > ...
<command> <(cmd1) <(cmd2)

# e.g.
{ echo 'hi'; echo 'my world'; } | wc -l
2

wc -l <(echo 'hi') <(echo 'my world')
      1 /dev/fd/63
      1 /dev/fd/62
      2 total
```



## Flow Control

```bash
if TEST-COMMAND
then
  STATEMENTS1
else
  STATEMENTS2
fi

if TEST-COMMAND1
then
  STATEMENTS1
elif TEST-COMMAND2
then
  STATEMENTS2
else
  STATEMENTS3
fi

for ...
do
...
done

while read line
do
...
done < file


while read x
do
	..."$x"
done < <(command)

while test-commands; do consequent-commands; done
until test-commands; do consequent-commands; done

# list of values
for var in a b c

# loop with parameter expansion
chars='a b c'
for var in $chars  # no double quotes to enable word splitting

# looping positional arguments of shell script
for i in $@

# loop values in an array  (declare -a mylist;mylist[0]=a;mylist[1]=b;)
for val in ${mylist[*]}

# for loop with command substition
for OUTPUT in $(Linux-Or-Unix-Command-Here)

# looping files
for file in /etc/*  # no double quotes to enable word splitting
for file in "$1"/*  # only double quotes the variable instead of the whole pattern

# loop range (1 2 3 4 5)
	for i in {1..5}  # Latest bash version 3.0+ has inbuilt support for setting up ranges:
	
    # 0 2 4 6 8 10
    for i in {0..10..2}

    # old-fashioned. `seq` command to create sequence for looping
    for i in $(seq 1 2 20)  # command substitution. print a sequence of numbers
    # Three-expression (heritage from C)
    for (( c=1; c<=5; c++ )) # `(())`: arithmetic expression. note expressions should be used intead of numbers

    # infinite loops
    for (( ; ; ))

# loop string and range
for x in run.{0..10}.txt

# conditional exit with break
for file in /etc/*
do
	if [ "${file}" == "/etc/resolv.conf" ]
	then
		break or continue
	fi
done

# select (menu)
select fname in *;
do
	echo you picked $fname \($REPLY\)
	break;
done

# case (switch)
case EXPRESSION in CASE1) COMMAND-LIST;; CASE2) COMMAND-LIST;; ... CASEN) COMMAND-LIST;; esac

case EXPRESSION in 
CASE1) COMMAND-LIST;; 
CASE2) COMMAND-LIST;; 
... 
CASEN) COMMAND-LIST;; 
esac

# example 1
echo "Select any option from the menu:"
read answer
case $answer in
1 | S )  echo "Searching text";;
2 | R )  echo "Replacing text";;
3 | D )  echo "Deleting text";;
*) echo "Try again.";;
esac

# example 2
echo -n "Enter the name of an animal: "
read ANIMAL
echo -n "The $ANIMAL has "
case $ANIMAL in
  horse | dog | cat) echo -n "four";;
  man | kangaroo ) echo -n "two";;
  *) echo -n "an unknown number of";;
esac
echo " legs."

```

### Read

```
read -a array < file  # read the first lin
read 

read -e -r -p "$prompt" -t 15 -i 'main' var || var='n'
-e: use bash readline command
-i: default string (must with -e)
-t: timeout secs
-p: prompt

# newline in string/prompt
read -p "Please Enter a Message:"$'\n' message
```



## Redirection

```
... 3>&-
# The 3>&- close the file descriptor number 3 (it probably has been opened before with 3>filename).

# Moving File Descriptors  (usage see https://unix.stackexchange.com/questions/65000/practical-use-for-moving-file-descriptors)
[n]<&digit-
[n]>&digit-  # short for n>&4 4>&-
# 3>&4- is a ksh93 extension also supported by bash and that is short for 3>&4 4>&-, that is 3 now points to where 4 used to, and 4 is now closed, so what was pointed to by 4 has now moved to 3.

[n]<>word  # Opening File Descriptors for Reading and Writing

`|&`: `2>&1 |` # Note: Since bash version 4 
e.g. <command> |& tee -a log  # <command> 2>&1 | tee -a log

<command> | tee <log>

<command> |& tee <log>
# same as
<command> 2>&1 | tee <log>
```

#### Duplicating File Descriptors

The redirection operator

```
[n]<&word
```

is used to duplicate input file descriptors. If word expands to one or more digits, the file descriptor denoted by n is made to be a copy of that file descriptor. If the digits in word do not specify a file descriptor open for input, a redirection error occurs. If word evaluates to ‘-’, file descriptor n is closed. If n is not specified, the standard input (file descriptor 0) is used.

The operator

```
[n]>&word
```

is used similarly to duplicate output file descriptors. If n is not specified, the standard output (file descriptor 1) is used. If the digits in word do not specify a file descriptor open for output, a redirection error occurs. If word evaluates to ‘-’, file descriptor n is closed. As a special case, if n is omitted, and word does not expand to one or more digits or ‘-’, the standard output and standard error are redirected as described previously.

## Function

```
function fname [()] compound-command [ redirections ]
```



## String Interpolation

```
name = ${filename%.*}
ext = ${filename##*.}
```

## Parameter Dereferencing

```
$var
```



## Parameter Expansion

https://tldp.org/LDP/abs/html/parameter-substitution.html

```
echo "${var}"
echo "Substitute the value of var."


echo "${var:-word}"
echo "If var is null or unset, word is substituted for var. The value of var does not change."


echo "${var:=word}"
echo "If var is null or unset, var is set to the value of word."


echo "${var:?message}"
echo "If var is null or unset, message is printed to standard error. This checks that variables are set correctly."


echo "${var:+word}"
echo "If var is set, word is substituted for var. The value of var does not change."
```

### Substitution/Replacement

```
${parameter/pattern/string}  # pattern matching syntax: https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html
```



### Default Values In Shell

ref: 
 - https://stackoverflow.com/questions/307503/whats-a-concise-way-to-check-that-environment-variables-are-set-in-a-unix-shell/307735#307735
 - https://stackoverflow.com/questions/2013547/assigning-default-values-to-shell-variables-with-a-single-command-in-bash

```
VARIABLE=${1:-DEFAULTVALUE}

#these commands act like the same
VARIABLE=${VARIABLE:-DEFAULTVALUE} # If variable not set or null, use default.
VARIABLE=${VARIABLE-DEFAULTVALUE} # If variable not set, use default.
VARIABLE=${VARIABLE:=DEFAULTVALUE} # If variable not set or null, set it to default.
VARIABLE=${VARIABLE=DEFAULTVALUE} # If variable not set or null, set it to default.
VARIABLE=${VARIABLE:?DEFAULTVALUE}
VARIABLE=${VARIABLE?DEFAULTVALUE}
: "${VARIABLE:=DEFAULTVALUE}"  # commonly used
: "${VARIABLE=DEFAULTVALUE}"
[ -z VARIABLE ] && VARIABLE=DEFAULTVALUE
```
### Differences between `:-`, `=`, `:=`
```
VARIABLE=${VARIABLE:-DEFAULTVALUE} # If variable not set or null, use default.
VARIABLE=${VARIABLE:=DEFAULTVALUE} # If variable not set or null, set it to default.
```
### Differences between `?` and `:?`
```
: ${STATE?"Need to set STATE"}
: ${DEST:?"Need to set DEST non-empty"}
```
or better
```
: "${STATE?Need to set STATE}"
: "${DEST:?Need to set DEST non-empty}"
```

## The Colon Command
- I should probably add that the colon command simply has its arguments evaluated and then succeeds. 
- the `:` command doesn't echo its arguments (but the shell does evaluate the arguments
- It is the original shell comment notation (before '#' to end of line). For a long time, Bourne shell scripts had a colon as the first character. The C Shell would read a script and use the first character to determine whether it was for the C Shell (a '#' hash) or the Bourne shell (a ':' colon). Then the kernel got in on the act and added support for '#!/path/to/program' and the Bourne shell got '#' comments, and the colon convention went by the wayside. But if you come across a script that starts with a colon, now you will know why.

## Internal Field Separator (IFS)
it's a character that separates fields

## Brace Expansion

https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html

```bash
$ echo /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
/usr/ucb/ex /usr/ucb/edit /usr/lib/ex?.?* /usr/lib/how_ex
$ echo a{d,c,b}e
ade ace abe
```



## Double Quotes
ref: https://github.com/koalaman/shellcheck/wiki/SC2086

```
echo $1
for i in $*; do :; done # this one and the next one also apply to expanding arrays.
for i in $@; do :; done
```

`$1` code looks like "print the first argument". It's actually "Split the first argument by IFS (spaces, tabs and line feeds). Expand each of them as if it was a glob. Join all the resulting strings and filenames with spaces. Print the result."
The second one looks like "iterate through all arguments". It's actually "join all the arguments by the first character of IFS (space), split them by IFS and expand each of them as globs, and iterate on the resulting list". 
The third one skips the joining part.

### My Test

```
echo 'echo "$0 $@"'
echo "$0 $@"
echo 'echo $1'
echo $1
echo 'echo "$1"'
echo "$1"
echo 'for i in $*; do echo $i; done'
for i in $*; do echo $i; done
echo 'for i in "$*"; do echo $i; done'
for i in "$*"; do echo $i; done
echo 'for i in $@; do echo $i; done'
for i in $@; do echo $i; done
echo 'for i in "$@"; do echo $i; done'
for i in "$@"; do echo $i; done
```


```
> sh test.sh 1\ 2\ 3 4 5
test.sh 1 2 3 4 5
echo $1
1 2 3
echo "$1"
1 2 3
for i in $*; do echo $i; done  # join and splitting by IFS
1
2
3
4
5
for i in "$*"; do echo $i; done  # join and splitting by IFS. Prevent globbing and word splitting
1 2 3 4 5
for i in $@; do echo $i; done  # splitting by IFS
1
2
3
4
5
for i in "$@"; do echo $i; done  # splitting by IFS. Prevent globbing and word splitting
1 2 3
4
5
```

## Logging 1
ref: https://www.cubicrace.com/2016/03/efficient-logging-mechnism-in-shell.html

```
#!/bin/sh

SCRIPT_LOG=/home/cubicrace/SystemOut.log
touch $SCRIPT_LOG

function SCRIPTENTRY(){
 timeAndDate=`date`
 script_name=`basename "$0"`
 script_name="${script_name%.*}"
 echo "[$timeAndDate] [DEBUG]  > $script_name $FUNCNAME" >> $SCRIPT_LOG
}

function SCRIPTEXIT(){
 script_name=`basename "$0"`
 script_name="${script_name%.*}"
 echo "[$timeAndDate] [DEBUG]  < $script_name $FUNCNAME" >> $SCRIPT_LOG
}

function ENTRY(){
 local cfn="${FUNCNAME[1]}"
 timeAndDate=`date`
 echo "[$timeAndDate] [DEBUG]  > $cfn $FUNCNAME" >> $SCRIPT_LOG
}

function EXIT(){
 local cfn="${FUNCNAME[1]}"
 timeAndDate=`date`
 echo "[$timeAndDate] [DEBUG]  < $cfn $FUNCNAME" >> $SCRIPT_LOG
}


function INFO(){
 local function_name="${FUNCNAME[1]}"
    local msg="$1"
    timeAndDate=`date`
    echo "[$timeAndDate] [INFO]  $msg" >> $SCRIPT_LOG
}


function DEBUG(){
 local function_name="${FUNCNAME[1]}"
    local msg="$1"
    timeAndDate=`date`
 echo "[$timeAndDate] [DEBUG]  $msg" >> $SCRIPT_LOG
}

function ERROR(){
 local function_name="${FUNCNAME[1]}"
    local msg="$1"
    timeAndDate=`date`
    echo "[$timeAndDate] [ERROR]  $msg" >> $SCRIPT_LOG
}

```

Usage Example
```
#!/bin/sh

source ./logger.sh
SCRIPTENTRY
updateUserDetails(){
    ENTRY
    DEBUG "Username: $1, Key: $2"
    INFO "User details updated for $1"
    EXIT
}

INFO "Updating user details..."
updateUserDetails "cubicrace" "3445"

rc=2

if [ ! "$rc" = "0" ]
then
    ERROR "Failed to update user details. RC=$rc"
fi
SCRIPTEXIT
```

Output
```
Execution output for demo.sh:
cat /home/cubicrace/SystemOut.log

[Tue Sep 27 20:13:50 IST 2016]    [DEBUG]        > demo SCRIPTENTRY
[Tue Sep 27 20:13:50 IST 2016]    [INFO]            Updating user details...
[Tue Sep 27 20:13:50 IST 2016]    [DEBUG]        > updateUserDetails ENTRY
[Tue Sep 27 20:13:50 IST 2016]    [DEBUG]        Username: cubicrace, Key: 3445
[Tue Sep 27 20:13:50 IST 2016]    [INFO]            User details updated for cubicrace
[Tue Sep 27 20:13:50 IST 2016]    [DEBUG]        < updateUserDetails EXIT
[Tue Sep 27 20:13:50 IST 2016]    [ERROR]         Failed to update user details. RC=2
[Tue Sep 27 20:13:50 IST 2016]    [DEBUG]        < demo SCRIPTEXIT
```

### `$FUNCNAME`
- Its a global internal variable maintained by any linux shell. 
- Its of type array and consists the name of the current function from where we are trying to read its value. 
- FUNCNAME[0] is the current function name and FUNCNAME[1] is the previous function name and so on ... Its a stack-trace of functions executed by a shell script. 
- Value of FUNCNAME gets cleared every-time we execute a new shell script.

## Logging 2

ref:
- https://unix.stackexchange.com/questions/145651/using-exec-and-tee-to-redirect-logs-to-stdout-and-a-log-file-in-the-same-time
- https://serverfault.com/questions/103501/how-can-i-fully-log-all-bash-scripts-actions

```
#!/bin/bash
# exec 3>&1 4>&2  # optional
# trap 'exec 2>&4 1>&3' 0 1 2 3  # optional
exec &>> "$log_file"

# or

exec > >(tee -i logfile.txt)
exec &> >(tee -a "$log_file")
# Everything below will go to the file $log_file:
```

*trap 0: If a sigspec is EXIT (0) the command arg is executed on exit from the shell.* (different from 0 signal in `kill`, which just dry-run kill)

## Signals in Shell
ref: https://unix.stackexchange.com/questions/251195/difference-between-less-violent-kill-signal-hup-1-int-2-and-term-15
SIGKILL never fails to kill a running process, that's the point. Other signals exist to give the application a chance to react.

The default behavior of SIGINT, SIGTERM, SIGQUIT and SIGHUP is to kill the program. However applications are allowed to install a handler for these signals. So the actual behavior of applications when they receive these signals is a matter of convention (which each application may or may not follow), not of system design.

SIGINT is the “weakest” of the lot. Its conventional meaning is “stop what you're doing right now and wait for further user input”. It's the signal generated by Ctrl+C in a terminal. Non-interactive programs generally treat it like SIGTERM.

SIGTERM is the “normal” kill signal. It tells the application to exit cleanly. The application might take time to save its state, to free resources such as temporary files that would otherwise stay behind, etc. An application that doesn't want to be interrupted during a critical application might ignore SIGTERM for a while.

SIGHUP is about the same as SIGTERM in terms of harshness, but it has a specific role because it's automatically sent to applications running in a terminal when the user disconnects from that terminal (etymologically, because the user was connecting via a telephone line and the modem hung up). SIGHUP is often involuntary, unlike SIGTERM which has to be sent explicitly, so applications should try to save their state on a SIGHUP. SIGHUP also has a completely different conventional meaning for non-user-facing applications (daemons), which is to reload their configuration file.

SIGQUIT is the harshest of the ignorable signals. It's meant to be used when an application is misbehaving and needs to be killed now, and by default it traditionally left a core dump file (modern systems where most users wouldn't know what a core file is tend to not produce them by default). Applications can set a handler but should do very little (in particular not save any state) because the intent of SIGQUIT is to be used when something is seriously wrong.
SIGQUIT should not only leave a core dump, but also omit most of/all of the cleanups (like deleting temporary files); I always think of it of a somewhat debugging signal; "Certain kinds of cleanups are best omitted in handling SIGQUIT. For example, if the program creates temporary files, it should handle the other termination requests by deleting the temporary files. But it is better for SIGQUIT not to delete them, so that the user can examine them in conjunction with the core dump." gnu.org/software/libc/manual/html_node/Termination-Signals.html – SantaXL Dec 15 '19 at 14:52

## `SIGSPEC`: `EXIT`/`RETURN`/`DEBUG`/`ERR`

ref: https://www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Builtins.html

If a sigspec is 0 or EXIT, arg is executed when the shell exits. If a sigspec is DEBUG, the command arg is executed before every simple command, for command, case command, select command, every arithmetic for command, and before the first command executes in a shell function ...

If a sigspec is ERR, the command arg is executed whenever a pipeline (which may consist of a single simple command), a list, or a compound command returns a non-zero exit status, subject to the following conditions ...

Both `SIGSPEC` and signals can be trapped with `trap` command

## Command Substitution

Command substitution allows the output of a command to replace the command itself. Command substitution occurs when a command is enclosed as follows:

```
$(command)
#or
`command`
```

## Arithmetic Expansion/Expression

https://tldp.org/LDP/abs/html/arithexp.html

Arithmetic expansion allows the evaluation of an arithmetic expression and the substitution of the result.

`(( expression ))`: expression execution

`$(( expression ))`: expansion

```
# 1. backticks (old-fashioned. superceded by 2 and 3)
z=`expr $z + 3`          # The 'expr' command performs the expansion.

# 2. double parentheses 
# ((EXPRESSION)) executes the expression
# $((EXPRESSION)) executes the expression AND do paramater dereferencing (expansion). Used for assignment
z=$(($z+3))
z=$((z+3)) #  Within double parentheses, parameter dereferencing is optional.
(( n += 1 ))

# -- no error --
(( n + 1 ))


# -- has error --
z=(( n + 1 )) no value expanded. Needs '$' to expand and then assigned to z via '='  # error message: syntax error near unexpected token `('

$(( n + 1 ))
$(( $n + 1 )) will execute the expression and expand the result. And it will induce error if this is called only because there is no command named, e.g., 1 or 2

(( $n += 1 )) will induce error because $n will be expanded to value and value cannot be assigned. On the contrary, the above one 'n' is a variable instead, which can be assigned.
$(( n += 1 )) will execute the expression and expand the parameter $n. And it will induce error if this is called only because there is no command named, e.g., 1 or 2, the value expanded by $n

# 3. let
let z=z+3
let "z += 3"  #  Quotes permit the use of spaces in variable assignment.
              #  The 'let' operator actually performs arithmetic evaluation,
              #+ rather than expansion.
```

## Process Substitution

Process substitution allows a process’s input or output to be referred to using a filename. Process substitution uses `/dev/fd/<n>` files to send the results of the process(es) within parentheses to another process. It takes the form of

```sh
<(command_list)  # Redirect command_list's stdout content to file /dev/fd/<n> and the file (filename) serves as an arg to outter command
```

or

```sh
>(command_list)  # file /dev/fd/<n> serve as an arg to outter command. Then redirect the file content to command_list's stdin
```

```
# check which /dev/fd/<n> 
echo <(true)  # same as true > /dev/fd/<n>; echo /dev/fd/<n>
echo >(true)  # same as echo /dev/fd/<n>; true < /dev/fd/<n>
echo >(true) <(true)  # same as true > /dev/fd/1; echo /dev/fd/2 /dev/fd/1; true < /dev/fd/2

diff <(ls $first_directory) <(ls $second_directory)
comm <(ls -l) <(ls -al)

while read x
do
	..."$x"
done < <(command)

tar cf >(bzip2 -c > file.tar.bz2) $directory_name
# same as
tar cf /dev/fd/?? $directory_name
bzip2 -c < /dev/fd/?? > file.tar.bz2
rm /dev/fd/??

ls > >(wc -l)  # ls | wc -l  or  ls > /dev/fd/??; wc -l < /dev/fd/??
wc -l <(ls)
wc -l < <(ls)
# note that: `wc -l $(ls)` is different that it runs `wc -l` for each listed names

```

see [this](https://tldp.org/LDP/abs/html/process-sub.html#:~:text=Process%20substitution%20feeds%20the%20output,the%20stdin%20of%20another%20process.&text=There%20is%20no%20space%20between,would%20give%20an%20error%20message.&text=Bash%20creates%20a%20pipe%20with,%2D%2DfIn%20and%20fOut%2D%2D.) for more examples.

## Here Documents

This type of redirection instructs the shell to read input from the current source until a line containing only word (with no trailing blanks) is seen. All of the lines read up to that point are then used as the standard input (or file descriptor n if n is specified) for a command.

- No parameter and variable expansion, command substitution, arithmetic expansion, or filename expansion is performed on `word`.
- If any part of `word` is quoted, 
  - the delimiter is the result of quote removal on word, and 
  - the lines in the here-document are **not expanded**. 
- If `word` is unquoted, 
  - all lines of the here-document are subjected to parameter expansion, command substitution, and arithmetic expansion, 
  - the character sequence `\newline` is ignored, and 
  - ‘\’ must be used to quote the characters ‘\’, ‘$’, and ‘`’.


```
[n]<<[-]word
        here-document
delimiter
```

```
$ sed 's/a/b/g' << EOF
aaa
EOF
=> bbb
```

If the redirection operator is <<-, then all leading tab characters are stripped from input lines and the line containing delimiter. This allows here-documents within shell scripts to be indented in a natural fashion.

e.g.

```bash
cat <<EOF > print.sh
#!/bin/bash
echo \$PWD
echo $PWD
EOF

#same as below

cat <<-EOF > print.sh
	#!/bin/bash
	echo \$PWD
	echo $PWD
EOF
```

## Here Strings

The word undergoes 

- tilde expansion, parameter and variable expansion, command substitution, arithmetic expansion, and quote removal. 
- Filename expansion and word splitting are not performed. 
- The result is supplied as a single string, with a newline appended, to the command on its standard input (or file descriptor n if n is specified).

```
[n]<<< word
```
```
$ sed 's/a/b/g' <<< 'aaa'  
bbb

# same as 
$ echo 'aaa' > tmp && sed 's/a/b/g' tmp
bbb
$ sed 's/a/b/g' <(echo 'aaa')
bbb
```



## set / shopt

```
set -o <bashopt>  # set in $SHELLOPTS
set +o <bashopt>  # unset
shopt -s <shellopt>  # set in $BASHOPTS
shopt -u <shellopt>  # unset
setopt  # zsh
unsetopt

shopt  # show $BASHOPTS
shopt -o  # show $SHELLOPTS

```

## Options
1. noclobber (不破壞)
   - `>` will not overwrite (fail if the file exists)
   - `>>` will not create file (fail if the file does not exist)

turn on/off `noclobber`

```
set -o/+o noclobber  # set in $SHELLOPTS
```


temporarily turn off `noclobber`

```
ls >| file  # bash
ls >! file  # tcsh
ls >>| file  # bash
ls >>! file  # tcsh
```